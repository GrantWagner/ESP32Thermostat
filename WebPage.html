<!DOCTYPE html>
<!-- With respect to https://codepen.io/dalhundal/pen/KpabZB -->
<html>
<head>
<style>

body {
  background-color: #CCCCCC;
}
#thermostat {
  width: 50vmin;
  height: 50vmin;
  margin: 0 auto;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}
.dial {
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}
.dial.away .dial__lbl--target {
  visibility: hidden;
}
.dial .dial__shape {
  transition: fill 0.5s;
}
.dial__editableIndicator {
  fill: white;
  fill-rule: evenodd;
  opacity: 0;
  transition: opacity 0.5s;
}
.dial--edit .dial__editableIndicator {
  opacity: 1;
}
.dial--state--off .dial__shape {
  fill: #222;
}
.dial--state--heating .dial__shape {
  fill: #E36304;
}
.dial__ticks path {
  fill: rgba(255, 255, 255, 0.3);
}
.dial__ticks path.active {
  fill: rgba(255, 255, 255, 0.8);
}
.dial text {
  fill: white;
  text-anchor: middle;
  font-family: Helvetica, sans-serif;
  alignment-baseline: central;
}
.dial__lbl--target {
  font-size: 120px;
  font-weight: bold;
}
.dial__lbl--ambient {
  font-size: 22px;
  font-weight: bold;
}
@font-face {
  font-family: 'Open Sans';
  font-style: normal;
  font-weight: 300;
  font-stretch: normal;
  src: url(https://fonts.gstatic.com/s/opensans/v40/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsiH0B4gaVc.ttf) format('truetype');
}
#controls {
  font-family: Open Sans;
  background-color: rgba(255, 255, 255, 0.25);
  padding: 20px;
  border-radius: 5px;
  position: absolute;
  left: 50%;
  transform: translatex(-50%);
  margin-top: 20px;
}
#controls label {
  text-align: left;
  display: block;
}
#controls label span {
  display: inline-block;
  width: 200px;
  text-align: right;
  font-size: 0.8em;
  text-transform: uppercase;
}
#controls p {
  margin: 0;
  margin-bottom: 1em;
  padding-bottom: 1em;
  border-bottom: 2px solid #ccc;
}
}
</style>
</head>

<body>

<div id='container'>
    <div id='thermostat'></div>

    <div id='controls'>

        <p>
            Click and hold the dial, then drag left / right to change the target temperature.
        </p>

        <label><span>Target Temperature</span>
            <input type='range' min='40' max='80' value='68' id='input_target_temperature' step='1' />
        </label>

            <label><span>Current Temperature</span>
            <input type='range' min='-20' max='120' value='55' id='input_ambient_temperature' step='1' />
        </label>

            <label><span>State</span>
            <select id='input_state'>
                <option value='off'>Off</option>
                <option value='heating'>Heating</option>
            </select>
        </label>

    </div>

</div>

<script id="rendered-js">
var thermostatDial = (function() {

    /*
     * Utility functions
     */

    // Create an element with proper SVG namespace, optionally setting its attributes and appending it to another element
    function createSVGElement(tag,attributes,appendTo) {
        var element = document.createElementNS('http://www.w3.org/2000/svg',tag);
        attr(element,attributes);
        if (appendTo) {
            appendTo.appendChild(element);
        }
        return element;
    }

    // Set attributes for an element
    function attr(element,attrs) {
        for (var i in attrs) {
            element.setAttribute(i,attrs[i]);
        }
    }

    // Rotate a cartesian point about given origin by X degrees
    function rotatePoint(point, angle, origin) {
        var radians = angle * Math.PI/180;
        var x = point[0]-origin[0];
        var y = point[1]-origin[1];
        var x1 = x*Math.cos(radians) - y*Math.sin(radians) + origin[0];
        var y1 = x*Math.sin(radians) + y*Math.cos(radians) + origin[1];
        return [x1,y1];
    }

    // Rotate an array of cartesian points about a given origin by X degrees
    function rotatePoints(points, angle, origin) {
        return points.map(function(point) {
            return rotatePoint(point, angle, origin);
        });
    }

    // Given an array of points, return an SVG path string representing the shape they define
    function pointsToPath(points) {
        return points.map(function(point, iPoint) {
            return (iPoint>0?'L':'M') + point[0] + ' ' + point[1];
        }).join(' ')+'Z';
    }

    function circleToPath(cx, cy, r) {
        return [
            "M",cx,",",cy,
            "m",0-r,",",0,
            "a",r,",",r,0,1,",",0,r*2,",",0,
            "a",r,",",r,0,1,",",0,0-r*2,",",0,
            "z"
        ].join(' ').replace(/\s,\s/g,",");
    }

    function donutPath(cx,cy,rOuter,rInner) {
        return circleToPath(cx,cy,rOuter) + " " + circleToPath(cx,cy,rInner);
    }

    // Restrict a number to a min + max range
    function restrictToRange(val,min,max) {
        if (val < min) return min;
        if (val > max) return max;
        return val;
    }

    // Round a number to the nearest 0.5
    function roundHalf(num) {
        return Math.round(num*2)/2;
    }

    function setClass(el, className, state) {
        el.classList[state ? 'add' : 'remove'](className);
    }

    /*
     * The "MEAT"
     */

    return function(targetElement, options) {
        var self = this;

        /*
         * Options
         */
        options = options || {};
        options = {
            //TODOPull these out and join them somehow with with the html vlaues

            diameter: options.diameter || 400,
            minValue: options.minValue || -20, // Minimum value for target temperature
            maxValue: options.maxValue || 120, // Maximum value for target temperature
            numTicks: options.numTicks || 140, // Number of tick lines to display around the dial
            onSetTargetTemperature: options.onSetTargetTemperature || function() {}, // Function called when new target temperature set by the dial
        };

        /*
         * Properties - calculated from options in many cases
         */
        var properties = {
            tickDegrees: 300, //  Degrees of the dial that should be covered in tick lines
            rangeValue: options.maxValue - options.minValue,
            radius: options.diameter/2,
            ticksOuterRadius: options.diameter / 30,
            ticksInnerRadius: options.diameter / 8,
            hvac_states: ['off', 'heating'],
            dragLockAxisDistance: 15,
        }
        properties.lblAmbientPosition = [properties.radius, properties.ticksOuterRadius-(properties.ticksOuterRadius-properties.ticksInnerRadius)/2]
        properties.offsetDegrees = 180-(360-properties.tickDegrees)/2;

        /*
         * Object state
         */
        var state = {
            target_temperature: options.minValue,
            ambient_temperature: options.minValue,
            hvac_state: properties.hvac_states[0],
        };

        /*
         * Property getter / setters
         */
        Object.defineProperty(this,'target_temperature',{
            get: function() {
                return state.target_temperature;
            },
            set: function(val) {
                state.target_temperature = restrictTargetTemperature(+val);
                render();
            }
        });
        Object.defineProperty(this,'ambient_temperature',{
            get: function() {
                return state.ambient_temperature;
            },
            set: function(val) {
                state.ambient_temperature = roundHalf(+val);
                render();
            }
        });
        Object.defineProperty(this,'hvac_state',{
            get: function() {
                return state.hvac_state;
            },
            set: function(val) {
                if (properties.hvac_states.indexOf(val)>=0) {
                    state.hvac_state = val;
                    render();
                }
            }
        });

        /*
         * SVG
         */
        var svg = createSVGElement('svg',{
            width: '100%', //options.diameter+'px',
            height: '100%', //options.diameter+'px',
            viewBox: '0 0 '+options.diameter+' '+options.diameter,
            class: 'dial'
        },targetElement);
        // CIRCULAR DIAL
        var circle = createSVGElement('circle',{
            cx: properties.radius,
            cy: properties.radius,
            r: properties.radius,
            class: 'dial__shape'
        },svg);
        // EDITABLE INDICATOR
        var editCircle = createSVGElement('path',{
            d: donutPath(properties.radius,properties.radius,properties.radius-4,properties.radius-8),
            class: 'dial__editableIndicator',
        },svg);

        /*
         * Ticks
         */
        var ticks = createSVGElement('g',{
            class: 'dial__ticks'
        },svg);
        var tickPoints = [
            [properties.radius-1, properties.ticksOuterRadius],
            [properties.radius+1, properties.ticksOuterRadius],
            [properties.radius+1, properties.ticksInnerRadius],
            [properties.radius-1, properties.ticksInnerRadius]
        ];
        var tickPointsLarge = [
            [properties.radius-1.5, properties.ticksOuterRadius],
            [properties.radius+1.5, properties.ticksOuterRadius],
            [properties.radius+1.5, properties.ticksInnerRadius+20],
            [properties.radius-1.5, properties.ticksInnerRadius+20]
        ];
        var theta = properties.tickDegrees/options.numTicks;
        var tickArray = [];
        for (var iTick=0; iTick<options.numTicks; iTick++) {
            tickArray.push(createSVGElement('path',{d:pointsToPath(tickPoints)},ticks));
        };

        /*
         * Labels
         */
        var lblTarget = createSVGElement('text',{
            x: properties.radius,
            y: properties.radius,
            class: 'dial__lbl dial__lbl--target'
        },svg);
        var lblTarget_text = document.createTextNode('');
        lblTarget.appendChild(lblTarget_text);
        //
        var lblAmbient = createSVGElement('text',{
            class: 'dial__lbl dial__lbl--ambient'
        },svg);
        var lblAmbient_text = document.createTextNode('');
        lblAmbient.appendChild(lblAmbient_text);
        //

        /*
         * RENDER
         */
        function render() {
            renderHvacState();
            renderTicks();
            renderTargetTemperature();
            renderCurrentTemperature();
        }
        render();

        /*
         * RENDER - ticks
         */
        function renderTicks() {
            var vMin, vMax;
                vMin = Math.min(self.ambient_temperature, self.target_temperature);
                vMax = Math.max(self.ambient_temperature, self.target_temperature);
            var min = restrictToRange(Math.round((vMin-options.minValue)/properties.rangeValue * options.numTicks),0,options.numTicks-1);
            var max = restrictToRange(Math.round((vMax-options.minValue)/properties.rangeValue * options.numTicks),0,options.numTicks-1);
            //
            tickArray.forEach(function(tick,iTick) {
                var isLarge = iTick==min || iTick==max;
                var isActive = iTick >= min && iTick <= max;
                attr(tick,{
                    d: pointsToPath(rotatePoints(isLarge ? tickPointsLarge: tickPoints,iTick*theta-properties.offsetDegrees,[properties.radius, properties.radius])),
                    class: isActive ? 'active' : ''
                });
            });
        }

        /*
         * RENDER - current temperature
         */
        function renderCurrentTemperature() {
            lblAmbient_text.nodeValue = Math.floor(self.ambient_temperature);
            var peggedValue = restrictToRange(self.ambient_temperature, options.minValue, options.maxValue);
            degs = properties.tickDegrees * (peggedValue-options.minValue)/properties.rangeValue - properties.offsetDegrees;
            if (peggedValue > self.target_temperature) {
                degs += 8;
            } else {
                degs -= 8;
            }
            var pos = rotatePoint(properties.lblAmbientPosition,degs,[properties.radius, properties.radius]);
            attr(lblAmbient,{
                x: pos[0],
                y: pos[1]
            });
        }

        /*
         * RENDER - target temperature
         */
        function renderTargetTemperature() {
            lblTarget_text.nodeValue = Math.floor(self.target_temperature);
        }


        /*
         * RENDER - HVAC state
         */
        function renderHvacState() {
            Array.prototype.slice.call(svg.classList).forEach(function(c) {
                if (c.match(/^dial--state--/)) {
                    svg.classList.remove(c);
                };
            });
            svg.classList.add('dial--state--'+self.hvac_state);
        }

        /*
         * Drag to control
         */
        var _drag = {
            inProgress: false,
            startPoint: null,
            startTemperature: 0,
            lockAxis: undefined
        };

        function eventPosition(ev) {
            if (ev.targetTouches && ev.targetTouches.length) {
                return  [ev.targetTouches[0].clientX, ev.targetTouches[0].clientY];
            } else {
                return [ev.x, ev.y];
            };
        }

        function dragStart(ev) {
                setClass(svg, 'dial--edit', true);
                _drag.inProgress = true;
                _drag.startPoint = eventPosition(ev);
                _drag.startTemperature = self.target_temperature || options.minValue;
                _drag.lockAxis = undefined;
        };

        function dragEnd (ev) {
            setClass(svg, 'dial--edit', false);
            if (!_drag.inProgress) return;
            _drag.inProgress = false;
            if (self.target_temperature != _drag.startTemperature) {
                if (typeof options.onSetTargetTemperature == 'function') {
                    options.onSetTargetTemperature(self.target_temperature);
                };
            };
        };

        function dragMove(ev) {
            ev.preventDefault();
            if (!_drag.inProgress) return;
            var evPos =  eventPosition(ev);
            var dy = _drag.startPoint[1]-evPos[1];
            var dx = evPos[0] - _drag.startPoint[0];
            var dxy;
            if (_drag.lockAxis == 'x') {
                dxy  = dx;
            } else if (_drag.lockAxis == 'y') {
                dxy = dy;
            } else if (Math.abs(dy) > properties.dragLockAxisDistance) {
                _drag.lockAxis = 'y';
                dxy = dy;
            } else if (Math.abs(dx) > properties.dragLockAxisDistance) {
                _drag.lockAxis = 'x';
                dxy = dx;
            } else {
                dxy = (Math.abs(dy) > Math.abs(dx)) ? dy : dx;
            };
            var dValue = (dxy*getSizeRatio())/(options.diameter)*properties.rangeValue;
            self.target_temperature = roundHalf(_drag.startTemperature+dValue);
        }

        svg.addEventListener('mousedown',dragStart);
        svg.addEventListener('touchstart',dragStart);

        svg.addEventListener('mouseup',dragEnd);
        svg.addEventListener('mouseleave',dragEnd);
        svg.addEventListener('touchend',dragEnd);

        svg.addEventListener('mousemove',dragMove);
        svg.addEventListener('touchmove',dragMove);
        //

        /*
         * Helper functions
         */
        function restrictTargetTemperature(t) {
            return restrictToRange(roundHalf(t),options.minValue,options.maxValue);
        }

        function angle(point) {
            var dx = point[0] - properties.radius;
            var dy = point[1] - properties.radius;
            var theta = Math.atan(dx/dy) / (Math.PI/180);
            if (point[0]>=properties.radius && point[1] < properties.radius) {
                theta = 90-theta - 90;
            } else if (point[0]>=properties.radius && point[1] >= properties.radius) {
                theta = 90-theta + 90;
            } else if (point[0]<properties.radius && point[1] >= properties.radius) {
                theta = 90-theta + 90;
            } else if (point[0]<properties.radius && point[1] < properties.radius) {
                theta = 90-theta+270;
            }
            return theta;
        };

        function getSizeRatio() {
            return options.diameter / targetElement.clientWidth;
        }

    };
})();

/* ==== */

var nest = new thermostatDial(document.getElementById('thermostat'),{
    onSetTargetTemperature: function(v) {
        document.getElementById('input_target_temperature').value = +v;
    }
});

document.getElementById('input_target_temperature').addEventListener('input',function() {
    nest.target_temperature = this.value;
});
document.getElementById('input_ambient_temperature').addEventListener('input',function() {
    nest.ambient_temperature = this.value;
});
document.getElementById('input_state').addEventListener('change',function() {
    nest.hvac_state = this.value;
});
</script>
</body>
</html>
